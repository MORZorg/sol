#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
label{chp:gen}
\end_layout

\end_inset

Code generation
\end_layout

\begin_layout Standard
Starting from the tree generated by the syntactic analysis and the table
 produced by the semantical one, the 
\emph on
yygen 
\emph default
(again, written by us) function proceeds with the code generation.
 The function operates calling the recursive function 
\emph on
generate_code
\emph default
,
\emph on
 
\emph default
which proceeds starting from the root node and generating the code for all
 nodes from the tree's leftmost to the rightmost.
\end_layout

\begin_layout Standard
Since the function 
\emph on
yygen
\emph default
 operates on the product of the analysis steps, it doesn't check anything
 (if something was wrong, the compiler's execution would have been already
 stopped).
\end_layout

\begin_layout Section
S-code specification
\end_layout

\begin_layout Standard
The code generation translates the SOL code in S-code code, a very low level
 language not dissimilar from Assembly.
\end_layout

\begin_layout Standard
Everything is done on three global stacks
\begin_inset Foot
status open

\begin_layout Plain Layout
More details on the stacks are provided in Chapter 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{chp:scode}
\end_layout

\end_inset

.
\end_layout

\end_inset

: the 
\emph on
activation 
\emph default
stack, the 
\emph on
object
\emph default
 stack and the 
\emph on
instance 
\emph default
stack.
 The activation stack contains the function's activation records, describing
 a function's local environment, and an activation record is added on the
 stack at the moment of a function's call.
 An activation record contains a reference to the starting point of that
 function's objects on the object stack.
 The object stack contains object descriptors, each of which describing
 a single object with its size and value, or a reference to the position
 of the value on the instance stack if that's the memorization mode of the
 object.
 The instance stack contains instances of the objects.
\end_layout

\begin_layout Standard
Temporary values, such as partial results of an expression, are put on the
 instance stack and referred to through a temporary object on the object
 stack.
\end_layout

\begin_layout Standard
Every instruction has from zero to three operands and operates implicitly
 on the last values present on the stack (generally the last one or two).
 For example, the instruction to perform a sum of integers is called 
\emph on
IPLUS 
\emph default
and it has no operands: it takes the last two values present on the stack,
 sum them and put the result back on the stack.
 Obviously, as a standard procedure when using stacks, every value used
 is also consumed.
\end_layout

\begin_layout Standard
Note that the object stack contains an environment associated to every called
 function, and this environment can be divided in two parts: one 
\begin_inset Quotes eld
\end_inset

permanent
\begin_inset Quotes erd
\end_inset

 containing the objects defined in the function's header, and one 
\begin_inset Quotes eld
\end_inset

temporary
\begin_inset Quotes erd
\end_inset

 containing the objects used by the S-code instructions.
 The instructions that need to use the value of an object in the permanent
 part (such as an expression involving variables) make use of the instruction
 
\emph on
LOD
\emph default
 to copy that variable's value on top of the stack (or a composition of
 multiple instructions to refer to a struct's field or a position in a vector)
 and, then, use the copied temporary value instead of the permanent one.
 In the same way, an assignment is performed by calculating the assigned
 value on the top of the stack and, then, copying it in the permanent part
 with the instruction 
\emph on
STO
\emph default
.
\end_layout

\begin_layout Section
The yygen function
\end_layout

\begin_layout Standard
When the 
\emph on
yygen 
\emph default
function is called, it automatically retrieves the root of the Syntax Tree
 and passes it to the 
\emph on
generate_code
\emph default
 function.
 This function consists of a big switch of the node's type and, for every
 type, it generates an instance of 
\emph on
Code
\emph default
 (a structure pointing to a list of pointers to another structure 
\emph on
Stat
\emph default
, which in turn contains the actual instructions, see Code 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{lst:code_stat}
\end_layout

\end_inset

 for the structures definition) in different ways depending on the type.
 If the type of the node is 
\emph on
unqualified nonterminal
\emph default
, there is another big switch on the node's 
\emph on
n_val 
\emph default
(that is, the node's value determining the exact type of 
\emph on
nonterminal
\emph default
 represented).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=C,caption={Code and Stat structures},label={lst:code_
stat}]
\end_layout

\begin_layout Plain Layout

typedef struct code {
\end_layout

\begin_layout Plain Layout

	Stat* head;
\end_layout

\begin_layout Plain Layout

	int size;
\end_layout

\begin_layout Plain Layout

	Stat* tail;
\end_layout

\begin_layout Plain Layout

} Code;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct stat {
\end_layout

\begin_layout Plain Layout

	int address;
\end_layout

\begin_layout Plain Layout

	Operator op;
\end_layout

\begin_layout Plain Layout

	Lexval args[ MAX_ARGS ];
\end_layout

\begin_layout Plain Layout

	struct stat* next;
\end_layout

\begin_layout Plain Layout

} Stat;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
generate_code 
\emph default
function returns the code which is concatenated following the order of recursion
 and, in the end, yygen gets the full code.
\end_layout

\begin_layout Standard
The code is represented, as can be deduced by the structure definition in
 Code 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{lst:code_stat}
\end_layout

\end_inset

, as a list of S-code statements, each of which is represented with its
 address (number of line), operator, an array of arguments (with a maximum
 number of 3 arguments) and a pointer to the next instruction.
\end_layout

\begin_layout Standard
At the end of the code generation, the instructions are printed to a file
 with extension 
\emph on
ohana
\emph default
 (name funnily derived from the 
\emph on
sol 
\emph default
extension, because sol..solo..han..han solo..ohana :D) using a function called 
\emph on
output_code
\emph default
.
\end_layout

\begin_layout Subsection
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
label{sect:func_call_code}
\end_layout

\end_inset

Function problem
\end_layout

\begin_layout Standard
The generation of the code for function declarations and calls caused some
 problems because the call (which is translated as in Code 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{lst:scode_func_call}
\end_layout

\end_inset

) needs informations that can only be given after its code generation is
 done, but knowing that, for example, a function is allowed to call itself,
 the two code generations collide.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language={OHANA},caption={S-code of a function call},label={ls
t:scode_func_call}]
\end_layout

\begin_layout Plain Layout

PUSH	<number of formal parameters>
\end_layout

\begin_layout Plain Layout

		<number of local parameters>
\end_layout

\begin_layout Plain Layout

		<distance between the call environment and the definition one>
\end_layout

\begin_layout Plain Layout

GOTO <entry point of function in S-code>
\end_layout

\begin_layout Plain Layout

POP
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assuming that a function will only be called after it is defined, we decided
 to build a hashmap in which every function will put informations about
 itself at the time of its definition.
 This informations are the nesting of the environment in which it is defined
 and a reference to the 
\emph on
Stat
\emph default
 containing its first statement (that is, the instantiation of its first
 parameter, if the parameters are present).
 The hashmap also contains the number of objects defined in the function's
 environment, but this information can only be determined at the end of
 the function's body computation (the temporary variables for 
\emph on
for
\emph default
 cycles, for example, are part of the function's environment but are not
 defined in the header)[toglierei tutta la ()].
 The hashmap uses the function's oid as key.
\end_layout

\begin_layout Standard
When the code for a function call has to be generated, it retrieves the
 hashmap entry relative to the called function and it generates the instructions
 PUSH, GOTO and POP.
 At the moment of the call we can only be sure about the correctness of
 the second argument of PUSH (computed as actual nesting - definition nesting,
 the latter retrieved from the hasmap), therefore, the other two arguments
 are set as 0.
 At the end of the call, a new entry is put in a 
\emph on
stacklist, 
\emph default
containing the function's oid and a copy of the 
\emph on
Code
\emph default
 generated for the call (thus containing a pointer to the PUSH, GOTO and
 POP statements).
\end_layout

\begin_layout Standard
When the whole code has been generated, we process the entries in the call
 stacklist.
 Since now every function definition has been processed in full and the
 whole code has been produced, every entry in the hashmap will contain for
 sure the correct informations about the number of objects in the functions'
 environments, and the pointer to the first statement of every function
 will feature the correct code address.
 Therefore, for every entry in the stack we can retrieve the corresponding
 function descriptor (thanks to the oid) and substitute the first arguments
 of PUSH and GOTO with the right values.
\end_layout

\begin_layout Subsection
Instantiation of temporary variables
\end_layout

\begin_layout Standard
While executing some examples, we have found that the 
\emph on
istack
\emph default
 wasn't empty at the end of the execution, but it still contains a lot of
 instances.
 We also noticed that this problem is code-dependent, in particular depending
 on the fact that the code that we are executing contains or not any sort
 of cycle.
 Looking at the generated code we have found that, every time a cycle were
 in an example, a lot of instances were allocated in the 
\emph on
istack
\emph default
 due to the fact that the temporary variables were allocated every time
 a cycle was used.
 The problem will get stronger when the examples contained some nested cycles.
\end_layout

\begin_layout Standard
Our solution for this issue was to separate the execution from the variable
 instantiation code, saving those two parts separately and then appending
 the code for the variable instantiation after the the function variable
 instantiation, so every variable, temporary or not, defined in the whole
 function will be allocated only once.
\end_layout

\end_body
\end_document
