#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{chp:lex}
\end_layout

\end_inset

Lexical and Syntactical analysis
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=C}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our compiler is written in the C language.
 It is divided in three main parts that correspond to the three stages of
 compiling, executed in sequential order:
\end_layout

\begin_layout Itemize
The lexical and syntactical analysis of the language, presented in this
 chapter, that together aim at determining wether the given SOL source file
 is well-written or not and to construct a data structure that describes
 the code in a functional manner;
\end_layout

\begin_layout Itemize
The semantical analysis, presented in 
Chapter 
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{chp:sem}
\end_layout

\end_inset

, which aims at determinining if the written statements (which are correct
 due to the previous analysis) make sense (eg, performing the sum of an
 integer and a string makes no sense, therefore it is not semantically correct),
 relying on the data structure produced by the previous analysis;
\end_layout

\begin_layout Itemize
The code generation, presented in Chapter 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{chp:gen}
\end_layout

\end_inset

, which, given that the code is both well-written and semantically correct,
 translates it in a lower-level and standard code, easier to execute directly
 (and executed by the virtual machine, of which we talk in Part 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{prt:vm}
\end_layout

\end_inset

).
 The code is, again, generated starting from the data structure produced
 by the syntactical analysis, not from the 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 code.
\end_layout

\begin_layout Standard
Our compiler uses Lex and Yacc to perform lexical and syntactical analysis,
 respectively.
 These are two languages specifically designed for this purpose and they
 produce complete analyzer programs written in C.
\end_layout

\begin_layout Section
Lexical analyzer
\end_layout

\begin_layout Standard
Lex is used to produce a lexical analyzer in C language.
 After the lex file compilation, we get a C file defining a function called
 
\emph on
yylex
\emph default
.
 This function, given the input file, produces a data structure (called
 
\emph on
symbol table
\emph default
) containing all the symbols found in the code (constants, ids etc).
 If, during, the file analysis, an error is encountered (in the file is
 present something that shouldn't be), the 
\emph on
yylex 
\emph default
function stops and produces an error (calling the 
\emph on
yyerror
\emph default
 function).
\end_layout

\begin_layout Standard
The symbol table will be used, along with the source SOL file, by the syntactica
l analyzer to check the syntax and produce the 
\emph on
syntax tree
\emph default
, of which we talk in the next section.
\end_layout

\begin_layout Standard
The lex file is divided in three parts.
 In the first part of the lex file, lexical elements (a 
\emph on
lexeme
\emph default
) that need to be defined with a regular expression (such as the id) are
 defined, in the second part these lexeme are associated to a rule, and
 the last part contains mostly C functions used in the lex rules of the
 second part.
 The lexeme that don't need to be defined are those whose definition is
 fixed, such as the keywords and the operators.
\end_layout

\begin_layout Standard
The definition of lexeme for the SOL language is, for our compiler, the
 one presented in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:lex_regexp}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Lex definition of lexical elements},label={lst:lex_re
gexp}]
\end_layout

\begin_layout Plain Layout

alpha	[a-zA-Z]
\end_layout

\begin_layout Plain Layout

digit	[0-9]
\end_layout

\begin_layout Plain Layout

id	{alpha}({alpha}|{digit}|_)*
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

charconst	'([^
\backslash
']|
\backslash

\backslash
.)'
\end_layout

\begin_layout Plain Layout

intconst	{digit}+
\end_layout

\begin_layout Plain Layout

realconst	{digit}+
\backslash
.{digit}+
\end_layout

\begin_layout Plain Layout

boolconst	true|false
\end_layout

\begin_layout Plain Layout

strconst	
\backslash
"([^"
\backslash

\backslash
]|
\backslash

\backslash
.)*
\backslash
"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

comment	--.*
\end_layout

\begin_layout Plain Layout

spacing	([ 
\backslash
t])+
\end_layout

\begin_layout Plain Layout

sugar	[()
\backslash
[
\backslash
]{}.,;]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%x charconst 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rules associated to each lexeme must be in the form presented in Listing
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:lex_rule}
\end_layout

\end_inset

.
 The value returned by each rule must be a unique identifier of the found
 lexeme.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Lex rule},label={lst:lex_rule}]
\end_layout

\begin_layout Plain Layout

lexeme	{ /*C code to execute when such lexeme is found*/; return lexeme_descript
or; }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the fixed lexeme (keywords and other simple stuff), the rules are as
 simple the ones in in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:lex_keyword}
\end_layout

\end_inset

.
 The complexe lexeme, however, comprise a 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

, since they're not fixed.
 This value must be 
\begin_inset Quotes eld
\end_inset

elaborated
\begin_inset Quotes erd
\end_inset

 from the 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 (simple string) value presented in the variable 
\emph on
yytext
\emph default
 and put in a new variable that will be used to build the symbol table.
 The elaboration consists, normally, in the conversion of the value to the
 correct type.
 In our program, the destination variable is 
\emph on
lexval
\emph default
, instance of 
\emph on
Value, 
\emph default
a
\emph on
 
\emph default
C union that can contain any type of value (integer, real, string..).
 The rules for the complexe lexeme are all presented in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:lex_more}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Lex rule for a keyword},label={lst:lex_keyword}]
\end_layout

\begin_layout Plain Layout

func	{ SPAM( "FUNC" ); return( FUNC ); }
\end_layout

\begin_layout Plain Layout

char	{ SPAM( "CHAR" ); return( CHAR ); }
\end_layout

\begin_layout Plain Layout

int	{ SPAM( "INT" ); return( INT ); }
\end_layout

\begin_layout Plain Layout

real	{ SPAM( "REAL" ); return( REAL ); }
\end_layout

\begin_layout Plain Layout

string	{ SPAM( "STRING" ); return( STRING ); }
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Lex rules for constants and ids},label={lst:lex_more}
]
\end_layout

\begin_layout Plain Layout

{intconst}	{ SPAM( "INT_CONST" ); lexval.i_val = atoi( yytext ); return(
 INT_CONST ); }
\end_layout

\begin_layout Plain Layout

{strconst}	{ SPAM( "STR_CONST" ); yytext[ strlen( yytext ) - 1 ] = '
\backslash
0'; lexval.s_val = new_string( yytext + 1 ); return ( STR_CONST ); }
\end_layout

\begin_layout Plain Layout

{charconst}	{ SPAM( "CHAR_CONST" ); yytext[ strlen( yytext ) - 1 ] = '
\backslash
0'; lexval.s_val = new_string( yytext + 1 ); return( CHAR_CONST ); }
\end_layout

\begin_layout Plain Layout

{realconst}	{ SPAM( "REAL_CONST" ); lexval.r_val = atof( yytext ); return(
 REAL_CONST ); }
\end_layout

\begin_layout Plain Layout

{boolconst}	{ SPAM( "BOOL_CONST" ); lexval.b_val = ( yytext[ 0 ] == 'f' ?
 FALSE : TRUE ); return( BOOL_CONST ); }
\end_layout

\begin_layout Plain Layout

{id}	{ SPAM( "ID" ); lexval.s_val = new_string( yytext ); return( ID ); }
\end_layout

\begin_layout Plain Layout

{sugar}	{ SPAM( yytext ); return( yytext[ 0 ] ); }
\end_layout

\begin_layout Plain Layout

.	{ yyerror( STR_ERROR ); } 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last line of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:lex_more}
\end_layout

\end_inset

 means that whatever doesn't match the previous rules must result in an
 error (as in the regular expressions, 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 means any value).
 The 
\emph on
SPAM
\emph default
 function is simply a redefinition of fprintf pointing to the standard error.
\end_layout

\begin_layout Section
Syntactical analyzer
\end_layout

\begin_layout Standard
Similarly to Lex, Yacc is used to produce a syntactical analyzer in C.
 The compilation of the Yacc file produces a C file containing a function
 called 
\emph on
yyparse
\emph default
 that, given the source file and the Symbol Table produced by 
\emph on
yylex
\emph default
, checks its syntax correctness and produces another data structure (the
 
\emph on
Syntax Tree
\emph default
) if everything is correct.
\end_layout

\begin_layout Standard
The Syntax Tree is realized with the 
\emph on
Node
\emph default
 structure, presented in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:Node}
\end_layout

\end_inset

 along with the union 
\emph on
Value
\emph default
.
 A 
\emph on
Node
\emph default
 contains:
\end_layout

\begin_layout Itemize
The number of line in the code in which it appears;
\end_layout

\begin_layout Itemize
A 
\emph on
type
\emph default
, which says what the node represents.
 In particular, the type is represented as an enumerator which values are
 the 
\emph on
terminals
\emph default
 (integer constant, id, etc) and 
\emph on
nonterminals
\emph default
 (mathematical expressions, assignments, etc) allowed in SOL.
 To simplify the produced syntax tree, the nonterminals are divided in two
 categories: the 
\emph on
qualified 
\emph default
nonterminals are aggregated nonterminals that are then differentiated by
 mean of a qualifier (eg mathematical expressions are one type of nonterminal
 and their qualifier is the operator), while the 
\emph on
unqualified
\emph default
 nonterminals are those that cannot be aggregated (eg an if).
 To sum up things, the type can either be a terminal, a qualified nonterminal
 or the special value unqualified nonterminal.
 The specific type of unqualified nonterminal represented by the node is
 then contained in the node's value, and so does the qualifier;
\end_layout

\begin_layout Itemize
A 
\emph on
value
\emph default
, represented as an instance of the union 
\emph on
Value
\emph default
, that can be an elementary value (integer, string..) if the node is a terminal,
 a unique identifier determining the nonterminal type if the node is an
 unqualified nonterminal (the identifiers are represented as possible values
 of the enumerator 
\emph on
NonTerminal
\emph default
) or a unique identifier determining the qualifier to be used if the node
 is a qualified nonterminal (these are represented as possibile values of
 the enumerator 
\emph on
Qualifier
\emph default
);
\end_layout

\begin_layout Itemize
A pointer to the 
\emph on
leftmost child
\emph default
;
\end_layout

\begin_layout Itemize
A pointer to the 
\emph on
first right brother
\emph default
;
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={The Node structure},label={lst:Node}]
\end_layout

\begin_layout Plain Layout

typedef struct snode
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int line;
\end_layout

\begin_layout Plain Layout

	Value value;
\end_layout

\begin_layout Plain Layout

	TypeNode type;
\end_layout

\begin_layout Plain Layout

	struct snode* child;
\end_layout

\begin_layout Plain Layout

	struct snode* brother;
\end_layout

\begin_layout Plain Layout

} Node;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef union
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i_val;
\end_layout

\begin_layout Plain Layout

	char* s_val;
\end_layout

\begin_layout Plain Layout

	double r_val;
\end_layout

\begin_layout Plain Layout

	Boolean b_val;
\end_layout

\begin_layout Plain Layout

	Qualifier q_val;
\end_layout

\begin_layout Plain Layout

	Nonterminal n_val;
\end_layout

\begin_layout Plain Layout

} Value; 
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntactical analyzer (also called 
\emph on
parser
\emph default
) stores as global variable a pointer to the root node of the tree.
 
\end_layout

\begin_layout Standard
The Yacc file is divided in three parts, whose purpose is the same as that
 of those in a Lex file.
 Here, in the first part instead of defining the complexe lexeme we instruct
 Yacc about which these lexeme are, by defining all the possible unique
 identifiers returned by the Lex rules as 
\emph on
tokens
\emph default
.
 The second part contains 
\emph on
translation rules
\emph default
 for every syntactical element of the language (all those defined in the
 BNF description, presented in Chapter 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{chp:bnf}
\end_layout

\end_inset

), and the third part contains definitions for the C functions used in the
 translation rules.
\end_layout

\begin_layout Standard
A translation rule must create a Node and populate it with the appopriate
 informations.
 The structure of a translation rule is the one presented in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:translation_rule}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Structure of a translation rule},label={lst:translati
on_rule}]
\end_layout

\begin_layout Plain Layout

syntactical_element : /* definition as in the BNF */ { $$ = /* code that
 creates the Node */ }
\end_layout

\begin_layout Plain Layout

					| /* alternate definition */ { $$ = /* alternate code */ }
\end_layout

\begin_layout Plain Layout

					;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At the left of the colon there is the name of the element, at the right
 there is a sequence of definitions, each associated to a code that is executed
 to create the node when that particular definition is found.
 The definitions are separated by 
\begin_inset Quotes eld
\end_inset

|
\begin_inset Quotes erd
\end_inset

 and the rule must terminate with a semicolon.
\end_layout

\begin_layout Standard
In the code, the symbol 
\begin_inset Quotes eld
\end_inset

$$
\begin_inset Quotes erd
\end_inset

 represent the lhs of the rule, and the elements of a definition can be
 referred to as 
\begin_inset Quotes eld
\end_inset

$n
\begin_inset Quotes erd
\end_inset

, where n is the position of the element in the definition starting from
 1.
\end_layout

\begin_layout Standard
The 
\emph on
yyparse 
\emph default
function generated starting from the Yacc file is a recursive function.
 The code is searched recursively for structures that match the lhs of a
 translation rule.
 Once a match is found, for every element in the rhs the function is called
 again and the process keeps going until every element in the rhs is either
 a token (which means that it has been processed by 
\emph on
yylex
\emph default
 and its value is in the Symbol Table, therefore no further processing is
 required) or has been processed completely by the recursion.
 At this point, the Node for that rule can be processed and returned to
 the caller (which will be another rule or the main program if the rule
 was the root one).
\end_layout

\begin_layout Standard
Knowing how the parsing works, we can understand why there must always be
 a 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 rule that will be matched at the first call of 
\emph on
yyparse 
\emph default
(if the code is correct, obviously) and associates the result of the subsequent
 calls to the global 
\emph on
root
\emph default
 variable, instead of returning it to the caller (thus, assign it to $$)
 like the others.
 In Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{lst:some_rule}
\end_layout

\end_inset

 we present, as an example, the root translation rule and the translation
 rule for a function declaration.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Extract of the translation rules for SOL},label={lst:
some_rule}]
\end_layout

\begin_layout Plain Layout

program : func_decl { root = $1; }
\end_layout

\begin_layout Plain Layout

        ;
\end_layout

\begin_layout Plain Layout

func_decl : FUNC ID { $$ = new_terminal_node( T_ID, lexval ); }
\end_layout

\begin_layout Plain Layout

            '(' par_list ')' DEFINE domain
\end_layout

\begin_layout Plain Layout

            type_sect_opt var_sect_opt const_sect_opt func_list_opt func_body
\end_layout

\begin_layout Plain Layout

            {
\end_layout

\begin_layout Plain Layout

                $$ = new_nonterminal_node( N_FUNC_DECL );
\end_layout

\begin_layout Plain Layout

                $$->child = $3;
\end_layout

\begin_layout Plain Layout

                Node** current = &($$->child->brother);
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $5 );
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $8 );
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $9 );
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $10 );
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $11 );
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $12 );
\end_layout

\begin_layout Plain Layout

                current = assign_brother( current, $13 );
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          ;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that C code can be inserted in any position between the elements of
 the rhs, and it must produce something that will then be referred to as
 $n, just like a normal element.
 In the presented example, we use this method to create immediately a Node
 containing the id of the declared function, and this node is then assigned
 as leftmost child of the node created for the whole rule.
\end_layout

\end_body
\end_document
