#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
label{chp:scode}
\end_layout

\end_inset

Structure of the virtual machine
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstset{language=C}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Virtual Machine is built as a standalone program.
 This means that it is not directly fed with the compiled code, but it has
 to read it from a 
\emph on
ohana 
\emph default
file produced by the compiler.
 The file is read using 
\noun on
Lex
\noun default
 and 
\noun on
Yacc
\noun default
, and the Code structure originally generated by 
\emph on
yygen
\emph default
 is rebuilt inside the virtual machine, this time simplified in a vector
 of 
\emph on
Stat
\emph default
 structures.
 Then, the function 
\emph on
yyvm
\emph default
 is called.
 This function takes the code, saved in the global variable 
\emph on
program
\emph default
, and executes it statement by statement.
\end_layout

\begin_layout Standard
Being the 
\emph on
program
\emph default
 variable a vector, the 
\emph on
yyvm 
\emph default
function can simply iterate over its elements and execute each one of them
 using the function 
\emph on
execute
\emph default
, implemented as a big 
\emph on
switch
\emph default
 over the statement's instruction that calls the appropriate execution function
 in correspondance of each instruction.
 The iteration is done using a global counting variable 
\emph on
pc
\emph default
.
 Using a global variable that indicates the actual statement may seem very
 bad, but it allows us to perform a jump in the code (needed, since all
 the conditional constructs, loops and even function calls are performed
 via conditioned or unconditioned jumps) simply by changing the value of
 that variable.
\end_layout

\begin_layout Section
Virtual machine structures
\end_layout

\begin_layout Standard
As anticipated in Chapter 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{chp:gen}
\end_layout

\end_inset

, S-code is a language designed to be executed with the support of three
 global stacks.
 In our virtual machine, these stacks are called 
\emph on
astack
\emph default
,
\emph on
 ostack
\emph default
 and
\emph on
 istack
\emph default
 and are implemented as vectors of, respectively, pointers to 
\emph on
Adescr
\emph default
, pointers to 
\emph on
Odescr
\emph default
 and 
\emph on
byte
\emph default
s (which are simply chars, redefined for clarity with a 
\emph on
#define
\emph default
).
 The implementation as vectors allows for a simpler handling of the allocation,
 deallocation and reference of elements (the latter is done simply by recording
 the index of the referenced element).
\end_layout

\begin_layout Standard
All the instances are recorded as arrays of bytes.
\end_layout

\begin_layout Standard
The stacks, their base element's structures and a number of methods to interact
 with them are all defined in a file separated from the one defining the
 execution methods, called 
\emph on
support_structures.h
\emph default
.
 Each stack has the method 
\emph on
top 
\emph default
to access its last element (easily done considering that there are three
 global variables, 
\emph on
ap
\emph default
, 
\emph on
op 
\emph default
and 
\emph on
ip
\emph default
, that reference to the first empty position in each stack), the 
\emph on
astack 
\emph default
and 
\emph on
ostack
\emph default
 have 
\emph on
pop 
\emph default
and 
\emph on
push
\emph default
 methods while the 
\emph on
istack
\emph default
 has two particular methods to perform the same thing on multiple entries,
 called 
\emph on
allocate_istack 
\emph default
and
\emph on
 deallocate_istack
\emph default
.
 The different in the approach is useful because, while the first two stacks
 are normally required to allocate/deallocate one element at a time, it
 is almost always the case that the 
\emph on
istack
\emph default
 needs to allocate multiple elements (eg if I want to put an integer on
 the stack, I will need four bytes or more, therefore I will have to allocate
 four elements).
\end_layout

\begin_layout Standard
Since the 
\emph on
ostack
\emph default
 is required to allocate a fixed number of objects at the moment of a function
 call, there is also a method to perform such task called 
\emph on
enlarge_ostack
\emph default
.
\end_layout

\begin_layout Standard
The global variables 
\emph on
asize
\emph default
, 
\emph on
osize 
\emph default
and 
\emph on
isize 
\emph default
are used to keep track of the stacks' size and simplify their handling (eg
 check if a stack is full and needs to be reallocated in correspondance
 of a push).
\end_layout

\begin_layout Standard
The 
\emph on
Adescr 
\emph default
and 
\emph on
Odescr
\emph default
 structures are defined as in Code 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{lst:Adescr_Odescr}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Adescr and Odescr objects},label={lst:Adescr_Odescr}]
\end_layout

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	// Modality of saving of the object, either embedded or in the instance
 stack
\end_layout

\begin_layout Plain Layout

	Mode mode;
\end_layout

\begin_layout Plain Layout

	// Size of the object in bytes
\end_layout

\begin_layout Plain Layout

	int size;
\end_layout

\begin_layout Plain Layout

	// Value
\end_layout

\begin_layout Plain Layout

	ObjectVal inst;
\end_layout

\begin_layout Plain Layout

} Odescr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct {
\end_layout

\begin_layout Plain Layout

	// Number of objects contained in the activation record
\end_layout

\begin_layout Plain Layout

	int obj_number;
\end_layout

\begin_layout Plain Layout

	// Pointer to the first object of the activation record in object_stack
\end_layout

\begin_layout Plain Layout

	int first_object;
\end_layout

\begin_layout Plain Layout

	// Address were to return
\end_layout

\begin_layout Plain Layout

	int raddr;
\end_layout

\begin_layout Plain Layout

	// Address of the father (definition) in the astack
\end_layout

\begin_layout Plain Layout

	int alink;
\end_layout

\begin_layout Plain Layout

} Adescr;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An 
\emph on
Adescr
\emph default
 represents the activation record of a function, and is created and pushed
 on the 
\emph on
astack 
\emph default
every time a function is called.
 It contains informations on the function's local environment along with
 the reference to statement at which to return when the function's execution
 is done.
\end_layout

\begin_layout Standard
An 
\emph on
Odescr
\emph default
 represents an object and contains its instance's size and a reference to
 such instance.
 The instance can be saved in two 
\begin_inset Quotes eld
\end_inset

modes
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Itemize

\series bold
Embedded mode
\series default
: the 
\emph on
inst
\emph default
 field of the object is an array of bytes containing the instance;
\end_layout

\begin_layout Itemize

\series bold
Stack mode
\series default
: the 
\emph on
inst
\emph default
 field of the object is an integer referencing the position of the 
\emph on
istack
\emph default
 containing the first byte of the instance;
\end_layout

\begin_layout Standard
It's obvious that the stack mode will be preferred in the case of complex
 objects (structs and vectors), while the embedded mode is normally used
 for simple objects.
 All the 
\begin_inset Quotes eld
\end_inset

temporary
\begin_inset Quotes erd
\end_inset

 objects, simple or complex, are created in stack mode.
\end_layout

\begin_layout Standard
Moreover, a number of 
\begin_inset Quotes eld
\end_inset

mask
\begin_inset Quotes erd
\end_inset

 methods is used to push and pop temporary values of specific type on the
 stacks.
 These methods take care of splitting the values into bytes in the right
 way during the push and putting them back togheter at the moment of pop.
 These methods also create objects on the 
\emph on
ostack
\emph default
 to
\emph on
 
\emph default
reference the temporary values put on the 
\emph on
istack
\emph default
\SpecialChar \@.
 There is one of them for every elementary type of SOL (int, real, string,
 char, booleans are treated as chars) and they rely on the methods 
\emph on
push_bytearray
\emph default
 and 
\emph on
pop_bytearray
\emph default
.
\end_layout

\begin_layout Section
Example of execution method
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Only one example is reported because the details of all the instructions'
 execution methods are not particularly interesting and the code is heavily
 commented, if one would like to inspect it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given the premises of the previous section, the general execution scheme
 is pretty simple: access to temporary values is done via the pop/push mask
 functions, and access to objects is done by computing the object's index
 on the 
\emph on
ostack 
\emph default
starting from its environment offset (the definition environment of the
 object is retrieved on the 
\emph on
astack
\emph default
 by iterating over the 
\emph on
alink
\emph default
 of the activation records) and applying the object's oid as index within
 the activation record's list of objects.
\end_layout

\begin_layout Standard
The execution procedure for a function's call is explained in the following
 subsection, as an example and because more complex than the others.
\end_layout

\begin_layout Subsection
Function call execution
\end_layout

\begin_layout Standard
A function call, as we can recall from Section 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{sect:func_call_code}
\end_layout

\end_inset

, is composed of three separate instructions: 
\emph on
PUSH
\emph default
, 
\emph on
GOTO 
\emph default
and 
\emph on
POP
\emph default
.
 The execution methods for these instructions is reported in Code 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
ref{lst:func_call_exe}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption={Execution of a function call},label={lst:func_call_ex
e}]
\end_layout

\begin_layout Plain Layout

// Push the chain and element_number on the istack, in preparation of the
 call to GOTO, and instantiate a new activation record
\end_layout

\begin_layout Plain Layout

int sol_push( Value* args )
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int formals_size = args[ 0 ].i_val;
\end_layout

\begin_layout Plain Layout

	int locals_size = args[ 1 ].i_val;
\end_layout

\begin_layout Plain Layout

	int chain = args[ 2 ].i_val;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	enlarge_ostack( locals_size );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	push_int( formals_size );
\end_layout

\begin_layout Plain Layout

	push_int( locals_size );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifdef DEBUG
\end_layout

\begin_layout Plain Layout

	fprintf( stderr, "SOL pushed el#: %d, %d
\backslash
n", formals_size, locals_size );
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	push_int( chain );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifdef DEBUG
\end_layout

\begin_layout Plain Layout

	fprintf( stderr, "SOL pushed chain: %d
\backslash
n", chain );
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return MEM_OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// GOTO is used ONLY after a push, to perform a function call
\end_layout

\begin_layout Plain Layout

int sol_goto( Value* args )
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int entry_point = args[ 0 ].i_val;
\end_layout

\begin_layout Plain Layout

	int chain = pop_int();
\end_layout

\begin_layout Plain Layout

	int locals_size = pop_int();
\end_layout

\begin_layout Plain Layout

	int formals_size = pop_int();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Adescr* function_ar;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#ifdef DEBUG
\end_layout

\begin_layout Plain Layout

	fprintf( stderr, "SOL goto chain: %d
\backslash
n", chain );
\end_layout

\begin_layout Plain Layout

	fprintf( stderr, "SOL goto el#: %d, %d
\backslash
n", formals_size, locals_size );
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// The number of elements is given, the start point for its objects is
 the
\end_layout

\begin_layout Plain Layout

	// top of the stack (the objects will be instantiated as part of the
\end_layout

\begin_layout Plain Layout

	// function call, not before)
\end_layout

\begin_layout Plain Layout

	function_ar = malloc( sizeof( Adescr ) );
\end_layout

\begin_layout Plain Layout

	function_ar->obj_number = formals_size + locals_size;
\end_layout

\begin_layout Plain Layout

	function_ar->first_object = op - formals_size;
\end_layout

\begin_layout Plain Layout

	function_ar->raddr = pc + 1;
\end_layout

\begin_layout Plain Layout

	function_ar->alink = ap - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while( chain-- > 0 )
\end_layout

\begin_layout Plain Layout

		function_ar->alink = astack[ function_ar->alink ]->alink;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	push_astack( function_ar );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Jump to the entry point (first instruction will be the definition of
 the formals)
\end_layout

\begin_layout Plain Layout

	pc = entry_point - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return MEM_OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Clean the stacks after the last function call
\end_layout

\begin_layout Plain Layout

int sol_pop()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i;
\end_layout

\begin_layout Plain Layout

	ByteArray function_result = pop_bytearray();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for( i = 0; i < top_astack()->obj_number; i++ )
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		// All the instances of the current environment are on top of the
\end_layout

\begin_layout Plain Layout

		// istack, all I care about is to pop the correct total number of
\end_layout

\begin_layout Plain Layout

		// cells, not the exact cells for every object
\end_layout

\begin_layout Plain Layout

		if( top_ostack()->mode == STA )
\end_layout

\begin_layout Plain Layout

			deallocate_istack( top_ostack()->size );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		pop_ostack();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	pop_astack();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Restores the result obtained from the called function
\end_layout

\begin_layout Plain Layout

	push_bytearray( function_result.value, function_result.size );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return MEM_OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially, the 
\emph on
PUSH
\emph default
 instruction pushes its arguments on the stack.
 In addition to this, it calls the function 
\emph on
enlarge_ostack
\emph default
 to allocate enough space on the stack to accomodate all the objects in
 the function's local environment, avoiding the need for a realloc at every
 object push when the function's header code is executed (that code will
 contain a 
\emph on
NEW 
\emph default
or 
\emph on
NEWS
\emph default
 instruction for every parameter, variable and constant of the function;
 those instructions simply perform a push on the 
\emph on
ostack
\emph default
, and this causes the stack to be reallocated by the size one element if
 it is full; the enlargement performed by 
\emph on
PUSH 
\emph default
prevents these multiple reallocations).
\end_layout

\begin_layout Standard
The 
\emph on
GOTO 
\emph default
instruction retrieves the values put on the stack by the 
\emph on
PUSH
\emph default
 and creates a new activation record with these informations and puts it
 on the 
\emph on
astack
\emph default
.
 Note that the 
\emph on
raddr
\emph default
 field is, simply, a reference to the statement that follows the 
\emph on
PUSH
\emph default
.
 After that, it performs a jump to the first instruction of the function.
\end_layout

\begin_layout Standard
Finally, the 
\emph on
POP
\emph default
 clears the entries of the local environment from the three stacks, taking
 care of putting the function's return value back on the stack.
\end_layout

\end_body
\end_document
